
※ 설치

* styled-components 설치 : npm i styled-components
+ typeScript 인식용 설치 : npm i --save-dev @types/styled-components
+ vsCode EXTENSIONS에서 `vscode-styled-components`를 설치해주면 코딩 할 때 편리함.

* typeScript 설치
- URL : https://create-react-app.dev/docs/adding-typescript/
- 새로 생성 : npx create-react-app my-app --template typescript
- 기존 JavaScript CRA에서 생성 : npm install --save typescript @types/node @types/react @types/react-dom @types/jest

* react-query 설치 : npm i react-router-dom react-query
+ typeScript 인식용 설치 : npm i --save-dev @types/react-router-dom
+ react 18버전 이상일 시 설치 : npm i @tanstack/react-query

* react-apexChart 설치 : npm install --save react-apexcharts apexcharts

* react-helmet 설치 : npm i react-helmet
+ typeScript 인식용 설치 : npm i --save-dev @types/react-helmet

* recoil 설치 : npm i recoil

* react-hook-form 설치 : npm i react-hook-form

※ 단축키

 * 특정 텍스트 선택 : 원하는 텍스트를 드래그 후 Ctrl + d
 * 선택한 모든 텍스트에 가장 우측 끝으로 포커싱 : Shift + Alt + i
 * 현재 선택한 텍스트를 기준으로 우측 끝까지 문자열 선택 : Ctrl + Shift + →
 * 이모지 : Win + .

※ 용어

* @형식 Object : 'key-value' 쌍으로 이루어진 데이터 구조.
 - key는 문자열이며, value는 문자열/숫자/배열/다른 객체 등 다양한 형식으로 구성 가능
 - 주로 JavaScript에서 사용되며, JSON 형식에서도 동일한 개념으로 사용됨.
 EX) Object 형식
 let obj = {
    "name" : "Alice",
    "age" : 30,
    "isStudent" : false
 };

* @문법 Pseudo Selector `${}` : JavaScript에서 사용하는 템플릿 리터럴 문법으로, 변수나 표현식을 문자열 내에 삽입하는데 사용.
* @문법 Immediately Invoked Function Expression `(() => {...})()` : 함수를 정의하자마자 즉시 실행한다는 의미.
EX)
useEffect(() => {
    (async () => {
      const response = await fetch("https://api.coinpaprika.com/v1/coins");
      const json = await response.json();
      console.log(json.slice(0, 100));
      setCoins(json.slice(0, 100)); // json이 너무 많아 잘라낸것.
      setLoading(false);
    })();
  }, []);
  --> 비동기 함수로 생성된 내용을 즉시 실행하는 부분

* @문법 : 정규식 : 문자열에서 특정 패턴을 찾거나 일치시키기 위한 규칙을 정의한 표현식.
EX) /^[A-Za-z0-9._%+-]+@naver.com$/ 정규식 해석
--> A-Z, a-z : 영문자 / 0-9 : 숫자 / ._%+- : 각각 필요함 / $ : @naver.com으로 끝나는 것

* @컴포넌트 styled-components : React 식 CSS
EX) styled 기초
    const Father = styled.div`
        display: flex;
    `;

    function App() {
    return (
        <Father>
            <div style={{ backgroundColor: "teal", width: 100, height: 100 }}></div>
            <div style={{ backgroundColor: "tomato", width: 100, height: 100 }}></div>
        </Father>
    );
    }
--> div 태그로된 컴포넌트를 `Father`로 만들어 return에 대입시키는 방식이 styled-components이다.

EX) styled의 props와 components
    const Box = styled.div`
    background-color: ${(props) => props.bgcolor};
    width: 100px;
    height: 100px;
    `;

    const Circle = styled(Box)`
    border-radius: 50px;
    `;

    function App() {
    return (
        <Father>
        <Box bgcolor="teal" />
        <Circle bgcolor="tomato" />
        </Father>
    );
    }
--> Box와 같이 props를 생성하여 배경색 지정을 return에서 할 수 있게 전달할 수 있다.
--> Circle과 같이 Box styled를 그대로 가져와 원형이라는 추가 속성만 만들 수 있다.

EX) styled의 태그 변경
    const Btn = styled.button`
        color: white;
        background-color: tomato;
        border: 0;
        border-radius: 15px;
    `;

    function App() {
    return (
        <Father>
            <Btn>Log in</Btn>
            <Btn as="a">Log in</Btn>
        </Father>
    );
    }
--> Btn은 button 태그로 시작하였으나 return에서 `as`속성을 사용하면 태그를 변경할 수 있다.

EX) styled의 속성 지정
    const Input = styled.input.attrs({ required: true, maxLength: 10 })`
        background-color: tomato;
    `;
--> `attrs`를 통해 Input 컴포넌트를 이용하면 무조건 required, maxLength가 적용된다.

EX) 애니메이션 (네모 --> 동그라미 --> 네모)
    const rotationAnimation = keyframes`
        0% {
        transform:rotate(0deg);
        border-radius: 0px;
        }
        50% {
        transform:rotate(360deg);
        border-radius: 100px;
        }

        100% {
        transform:rotate(0deg);
        border-radius: 0px;
        }
    `;

    // linear : 애니메이션 속도가 일정하게 유지되도록 설정
    // infinite : 애니메이션이 무한반복되도록 설정
    const Box = styled.div`
        height: 200px;
        width: 200px;
        background-color: tomato;
        animation: ${rotationAnimation} 1s linear infinite;
    `;

    function App() {
    return (
        <Wrapper>
            <Box></Box>
        </Wrapper>
    );
    }
--> `keyframes`를 통해 애니메이션 styled를 생성
--> rotationAnimation 내용을 Box가 Pseudo Selector인 `${}`를 통해 가져감

EX) 자식 요소 styled components 지정

    const Emoji = styled.span`
        font-size: 36px;
    `;

    const Box = styled.div`
        ${Emoji} {
        &:hover {
            font-size: 98px;
            }
        }
    `;
--> Emoji로 지정한 styled components를 Box에서 Pseudo Selector인 `${}`로 가져와 지정할 수 있다.

EX) theme : 기본적으로 모든 색상들을 가지고 있는 Object.
- index.js
    const darkTheme = {
        textColor: "whitesmoke",
        backgroundColor: "#111",
    };

    const lightTheme = {
        textColor: "#111",
        backgroundColor: "whitesmoke",
    };

    const root = ReactDOM.createRoot(document.getElementById("root"));
    root.render(
        <ThemeProvider theme={darkTheme}>
            <App />
        </ThemeProvider>
    );

- App.js
    const Wrapper = styled.div`
        display: flex;
        height: 100vh;
        width: 100vw;
        justify-content: center;
        align-items: center;
        background-color: ${(props) => props.theme.backgroundColor};
    `;

    const Title = styled.h1`
        color: ${(props) => props.theme.textColor};
    `;

    function App() {
        return (
            <Wrapper>
            <Title>Hello</Title>
            </Wrapper>
        );
    }
--> `ThemeProvider`를 통해 자식 컴포넌트(App)에 theme props를 넘길 수 있다.
--> App.js에서 받은 theme props를 지정하면 index.js에서 theme props를 바꿀 때마다 같이 변경된다.

* createGlobalStyle : styled-components에 있으며, 한 컴포넌트 스타일을 전역에 뿌려주는 메소드


* interface : typescript에서 props가 어떤건지 알려줄 때 쓰는 방식
EX) 기초
    interface CircleProps {
        bgColor: string;
        borderColor?: string;
    }

    function Circle({bgColor} : CircleProps) {
    return <Container />;
    }
--> Props를 위와같이 interface로 지정해주고 아래에서 props를 선언하면 `CircleProps` 거라고 typescript에게 알린다.
--> `borderColor`와 같이 `?`을 넣어주면 무조건 해당 props를 입력하지 않아도 된다.

* Link : react-router-dom 이동 컴포넌트
1) <Link to={`/${coin.id}`} />는 그냥 이동만 하는 방식
2) <Link
        to={{
        pathname: /${coin.id},
        state: { name: coin.name },
        }}
    />
    --> 이 방식은 이동함과 동시에 이동된 컴포넌트에 state도 동시에 전달
    --> ! 이동된 컴포넌트에서 useLocation() 으로 가져올 수 있음
    EX)
    interface RouteState {
     name: string;
    }
    function Coin() {
        const {
            state
        } = useLocation<RouteState>();
        console.log(state);
    }

* useRouteMatch : 특정한 URL에 있는지의 여부를 알려주는 Hook
EX) const priceMatch = useRouteMatch("/:coinId/price");
--> 해당 경로에 들어가면 console.log로 Object 데이터를 보여줌
--> 결과 값 : 
{
    "path": "/:coinId/price",
    "url": "/btc-bitcoin/price",
    "isExact": true,
    "params": {
        "coinId": "btc-bitcoin"
    }
}
    

 * react-query : 서버 상태를 쉽게 관리해주는 라이브러리.
  ! react-query의 장점은 다른 페이지에 있다가 해당 페이지로 돌아온다 했을 때
  useState는 리렌더링을 하지만 react-query는 리렌더링을 하지 않는다.

  - const queryClient = new QueryClient(); : react-query 시작 client 생성
  - <QueryClientProvider client={queryClient}></QueryClient> : react-query 시작
  - ReactQueryDevtools : useQuery를 통해 보관된 캐시를 볼 수 있는 툴

  - useQuery(queryKey, options, {Choice Object}) : 고유 값인 queryKey와 이용 할 options을 넣어 
  react-query 캐시에 보관해주는 Hook이며 Choice Object와 같이 추가적으로 기능을 넣을 수 있다.
  EX) 기본적인 사용
  const { isLoading, data } = useQuery<ICoin[]>("allCoins", fetchCoins);
  --> 고유값은 allCoins
  --> fetchCoins라는 데이터를 가져오는 동안 isLoading 작업을 진행.
  --> 가져오기에 성공하면 data에 해당 데이터를 넣어줌.
  
  EX) 여러 useQuery를 사용할 경우
  const { isLoading: infoLoading, data: infoData } = useQuery<InfoData>(
    ["info", coinId],
    () => fetchCoinInfo(coinId)
  );
  const { isLoading: tickersLoading, data: tickersData } = useQuery<PriceData>(
    ["tickers", coinId],
    () => fetchCoinTickers(coinId),
    {
      refetchInterval: 5000,
    }
  );
  --> {} 내부에 이름이 겹치지 않게 바꿀 수 있음.
  --> queryKey의 경우 배열 형태로 구성되어 있음.
  --> 내가 가져오려는 options이 parameter가 필요할 경우 지연된 함수 실행인 '() =>'가 필요함.
  --> 두 번째 useQuery의 경우 3개의 요소가 들어가 있는데, 이 세 번째가 'Choice Object'의 기능이며, 5초마다 useQuery를 갱신해준다.

  * react-helmet : HTML <head> 요소의 내용을 대신 관리해줌.
  EX) 기본적인 사용
      <Helmet>
        <title>Coins</title>
      </Helmet>
      --> 이럴 경우 <head> 태그에 <title> 태그를 달은 것처럼 동작된다.(제목이 바뀜) 

* recoil : state를 직접 관리하여 이용하고 싶을 때 바로 state를 가져갈 수 있는 기능의 라이브러리.
 - RecoilRoot : recoil을 이용하려는 컴포넌트의 최상위 컴포넌트 쪽에 사용.
 - atom : 모든 곳에 사용하려는 state 값
 - useRecoilValue(atom) : 만들어 놓은 atom을 불러와주는 Hook
 - useSetRecoilState(atom) : atom의 기본값을 변경해주는 Hook
 - useRecoilState(atom) : useState와 유사하며, 전역적으로 상태를 공유하고 관리하는 것에 차이가 있음.
 - Selector : state를 입력 받아 변형하여 반환된 값인 derived state를 나타내줌. 또는 atom의 출력을 변형시키는 도구

EX) 기본 적인 state 이동 방식 App --> Chart
App --> Router --> Coin --> Chart
--> 위와 같이 자식인 컴포넌트에 props로 단계별 전달해야만 하위 컴포넌트인 Chart가 받을 수 있었다.

EX) recoil을 통해 만들어놓은 atom 이용
> atoms.ts
    import { atom } from "recoil";

    export const isDarkAtom = atom({
        key: "isDark",
        default: false,
    });
    --> key(state)와 default를 지정

> App.tsx
    function App() {
        const isDark = useRecoilValue(isDarkAtom);
        return (
            <>
            <ThemeProvider theme={isDark ? darkTheme : lightTheme}>
                <GlobalStyle />
                <Router />
                <ReactQueryDevtools initialIsOpen={true} />
            </ThemeProvider>
            </>
        );
    }
    --> useRecoilValue로 atoms.ts에 있는 isDarkAtom을 불러와 변수(isDark)로 변경 후 theme에 이용

EX) atom 변경
    const setterFn = useSetRecoilState(isDarkAtom)
    --> <button onClick={() => setterFn((prev) => !prev)}>Toggle Mode</button>

EX) selector 이용
    export const toDoState = atom<IToDo[]>({
        key: "toDo",
        default: [],
    });

    export const toDoSelector = selector({
        key: "toDoSelector",
        get: ({ get }) => {
            const toDos = get(toDoState);
            // filter : 기존 배열 형식 내부에서 원하는 조건으로 찾아와 배열로 다시 반환
            return [
            toDos.filter((toDo) => toDo.category === "TO_DO"),
            toDos.filter((toDo) => toDo.category === "DOING"),
            toDos.filter((toDo) => toDo.category === "DONE"),
            ];
        },
    });
    --> atom(toDoState)을 만들어 selector에서 변환되어 출력된다는 것을 알 수 있다.

* react-hook-form : form을 이용하는 작업을 용이하게 해주는 라이브러리.
  - useForm : 폼의 상태와 유효성 검사를 관리하는 Hook.
    - register : 폼 요소를 react-hook-form에 등록하여 해당 요소의 값을 폼 상태로 관리할 수 있게함.
    - watch : form 입력 값들의 변화를 관찰해주는 함수.
    - handleSubmit(유효 및 필수 데이터, 비유효 및 필수아닌 데이터) : form 에 있는 내용을 제출하는 함수.
    - formState: `isDirty(기본값에서 변경여부)`, `isValid(유효성)`, `errors(오류)`등의 속성을 통해 폼의 상태를 확인.
    - setError: 오류를 일으키는 함수
    - setValue: 특정 폼 필드의 값을 설정하거나 업데이트하는 함수

EX) 기본 예시
  const { register, watch, handleSubmit } = useForm();
  const onValid = (data: any) => {
    console.log(data);
  };
  console.log(watch());
  return (
    <div>
      <form onSubmit={handleSubmit(onValid)}>
        <input {...register("email")} placeholder="Write a email" />
        <input {...register("userName")} placeholder="Write a userName" />
        <input {...register("name")} placeholder="Write a name" />
        <input {...register("passWord")} placeholder="Write a passWord" />
        <input {...register("passWord1")} placeholder="Write a passwWord1" />

        <button>Add</button>
      </form>
    </div>
  );
  --> register를 통해 기본적인 입력 로직 추가(...register)
  --> watch를 통해 실시간 입력현황 확인

* Array 적용 및 즉시 출력 방안
  EX) 내가 원하는 객체를 등록하고 Array를 즉시 출력 시킬 때
  const onValid = ({ toDo }: IForm) => {
    console.log("add to do", toDo);
    setToDos((oldToDos) => [
      { text: toDo, id: Date.now(), category: "TO_DO" },
      ...oldToDos,
    ]);
    setValue("toDo", "");
  };
  --> setToDos를 보면 내가 원하는 객체({})를 등록한 다음에 기존 배열(...oldToDos)에 넣는 걸 알 수 있다.

  EX) Array 내부에 있는 내용을 일부 수정했을 때
  const onClick = (newCategory: IToDo["category"]) => {
    console.log("I wanna to ", newCategory);
    setToDos((oldToDos) => {
      // findIndex : 배열 내부에 index를 찾아주며, 아래 코드와 같이 조건부에 따라 특정 index를 가져올 수 있다.
      const targetIndex = oldToDos.findIndex((toDo) => toDo.id === id);
      const oldToDo = oldToDos[targetIndex];
      const newToDo = { text, id, category: newCategory };

      return [
        ...oldToDos.slice(0, targetIndex),
        newToDo,
        ...oldToDos.slice(targetIndex + 1),
      ];
    });
  };
  --> targetIndex는 내가 선택한 배열 번호이며, 이 변수를 이용하여 return에서 새로 반영할 수 있다.
  --> ...oldToDos.slice(0, targetIndex) : 내가 선택한 배열 번호의 앞쪽 배열을 보여줌.
  --> newToDo: 내가 변경한 내용을 반영
  --> ...oldToDos.slice(targetIndex + 1) : 내가 선택한 배열 번호의 뒤쪽 배열을 보여줌.(targetIndex + 1을 안하면 내가 선택한 배열도 포함됨)

* enum : 열거형의 줄임말로, 특정 값들의 집합에 이름을 부여한 타입.

EX) 기본 예시

export enum Categories {
  "TO_DO" = "TO_DO",
  "DOING" = "DOING",
  "DONE" = "DONE",
}

export const categoryState = atom<Categories>({
  key: "category",
  default: Categories.TO_DO,
});

--> "TO_DO"가 string이 아닌 그냥 "TO_DO" 자체가 타입이라는 걸 enum에서 알림
--> enum을 가지고 형식처럼 사용
